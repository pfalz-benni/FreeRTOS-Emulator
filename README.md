# ESPL Exercises by Benedikt Witteler

This is the solution to the exercise part of the TUM ESPL.

## What is where?

### Git-Exercise:
<https://github.com/pfalz-benni/git-tutorial-duplicate>  
Since this is a private repository (by the time I finished the exercise it wasn't clear whether the git exercise repository was supposed to be private or public) I invited "PhilippvK" (already a collaborator) and "alxhoff" (pending invite) to the repository. As a private repository it cannot be a fork.  
*For completeness: The fork I originally made is <https://github.com/pfalz-benni/git-tutorial> but this version is not supposed to be graded.*

### Exercises 2, 3 and 4:
Here in the submitted folder. It is a copy of the exercises branch of the repository <https://github.com/pfalz-benni/FreeRTOS-Emulator/tree/exercises>.

## How to run the programm for exercises 2, 3 and 4?
Move into the build folder, run `cmake ..` to create a make file and run `make` in the same directory to build the project. The executable is created in the bin folder with the name FreeRTOS_Emulator.  

To switch between the solutions to exercises 2, 3 and 4 that are displayed on different screens press the button `E` on your keyboard.  

- Exercise 2: you can press the buttons `A, B, C, D` and move the mouse on the screen. The programm will react accordingly. To reset the counters for `A, B, C, D` press the left or the right mouse button.

- Exercise 3: To increment the numbers on the screen press `N` (counting task triggered by a task notification) or `S` (counting task triggered by a semaphore). Their value is reset to zero with a period of 15 seconds. To pause or resume the counter, counting the seconds passed since the launch of the program presse `P`.

- Exercise 4: There is no user input in this exercise. Only the outputs of the different tasks are printed on the screen.

## Answers to the exercise questions

### 2.3.1: How does the mouse guarantee thread-safe functionality?
The variables holding the mouse coordinates are protected using a mutex.

### 3.1: What is the kernel tick?
The kernel tick is a periodic interrupt generated by a hardware timer. It has a fixed period (fixed frequency) that can be configured in the FreeRTOSConfig.h. The kernel tick is used to measure real time so that the kernel can wake up, unblock or manage a tasks as programmed. Every tick (but also in-between ticks if necissary) the scheduler is called to evaluate which tasks to execute.

### What is a tickless kernel?
A tickless kernel doesn’t use hardware-generated timer interrupts. Timer interrupts are only generates as they are required i.e. when there are tasks to manage. FreeRTOS provides a low power tickless mode in which there are no periodic ticks to save power.

### 3.2.2: Experiment with the task stack size. What happens if it is too low?
For me nothing happened, no matter how low the number was I set the stack size to. However, usually the program should crash because FreeRTOS doesn’t realize the concept of for example a swap memory where the RAM can be emptied. So if the memory is full the program might try to access memory it’s not allowed to access and cause a segmentation fault.


### 4.0.3 Play around with the priorities from exercise in Section 3.3.2 (e.g. set all priorities to the same value, inverse the priority order, etc.). What can you observe?
Output depends on where within one tick the a task is executed. If a task has a higher priority it is executed earlier.

## Documentation
A small doxygen documentation for the exercise part of the ESPL can be found in the docs folder. In there, it is created using the command `doxygen DoxyfileExercises`.